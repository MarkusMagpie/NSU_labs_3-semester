1 print tuple
TuplePrinter.h
перегрузим оператор << для печати кортежа (std::tuple) 

2 класс CSVParser
CSVParser.h
обрабатывает CSV-файл и возвращает строки в виде кортежей с разделителем
lazy evaluation - ленивая обработка - строки файла читаются из файла по мере необходимости(?)

КОМПИЛЯЦИЯ:
g++ -o csv_parser *.cpp -std=c++17

План рассказа:
1 таск - используя рекурсивные шаблоны реализовать оператор для печати std:tuple
    TuplePrinter.h
    Кортеж (std::tuple) — это набор значений различных типов, где каждый элемент имеет уникальный индекс. 
    В C++ нельзя напрямую вывести std::tuple в поток, потому что стандартная библиотека не поддерживает такую операцию.
    Значит нам нужна кастомная перегрузка оператора << (в чем собственно и заключается задание)
    --------------------------------------------------------------------------------------
    template<typename Tuple, std::size_t... Is>
    void print_tuple_impl(std::ostream& os, const Tuple& t, std::index_sequence<Is...>) {
        ((os << (Is == 0 ? "" : ", ") << std::get<Is>(t)), ...);
    }

    функция print_tuple_impl реализует вывод каждого элемента кортежа t в поток os, разделённый запятыми.
    Она принимает три аргумента:
        std::ostream& os — поток вывода, в который записывается кортеж.
        const Tuple& t — сам кортеж, элементы которого мы будем печатать.
        std::index_sequence<Is...> — последовательность индексов, которая позволяет обращаться к элементам кортежа по их порядковым номерам.
    
    ((os << (Is == 0 ? "" : ", ") << std::get<Is>(t)), ...);
        строка выше использует fold expresssion:
            (pack op ...): Unary Left Fold. Где op - 1 из 32 бинарных операторов. У нас ",".
                последовательно вызывает операцию для всех индексов последовательности Is.
                https://en.cppreference.com/w/cpp/language/fold
                https://www.geeksforgeeks.org/cpp-17-fold-expressions/
            std::get<Is>(t) - элемент кортежа t по его индексу Is. 
                Например, std::get<0>(t) вернёт первый элемент.
            Is == 0 ? "" : ", ": Если индекс элемента Is равен 0, добавляется пустая строка. Иначе - пробел
    --------------------------------------------------------------------------------------
    template<typename... Args>
    std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& t) {
        os << "(";
        print_tuple_impl(os, t, std::index_sequence_for<Args...>{});
        os << ")";
        return os;
    }

    шаблонная функция перегружает оператор << для вывода кортежа t в поток os
    Принимает два аргумента:
        std::ostream& os — поток вывода, в который записывается кортеж.
        const std::tuple<Args...>& t - шаблонный кортеж, элементы которого выводим в поток вывода. 
        (Шаблонный - принимает кортежи с любым количеством и типом элементов)
    std::index_sequence_for<Args...>{} - генерирует индексную последовательность для всех элементов кортежа t.
        Например: для кортежа из трёх элементов - последовательность 0, 1, 2.  
        https://en.cppreference.com/w/cpp/utility/integer_sequence  
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
2 таск - CSVParser
    SUBTASK 2 AND 3 TEST
    operator++
    begin
    end
    |operator!=
    |operator*
    |iteration
    |(Name, Abbreviation, Numeric, Numeric-2)
    |operator++
    ||operator!=
    ||operator*
    ||iteration
    ||(Monday, Mon., 1, 01)
    ||operator++
    --------------------------------------------------------------------------------------
    ОБЩАЯ ЛОГИКА
    Когда используется for (auto row : parser) в main.cpp, компилятор интерпретирует это как итерацию по объекту parser. 
    Каждый раз, когда цикл переходит к следующей итерации, объект разыменовывается, давая нам кортеж current_tuple, 
        а у него вызывается operator++ у parser. 
    Этот оператор++ перемещает нас к следующей строке CSV-файла, обновляя current_tuple новой строкой.
    А current_tuple выводится перегруженным оператором << из 1 таска
    
    for (const auto& row : parser)
        1 инициализация итератора
            Вызов метода begin для получения объекта-итератора
        2 проверка на завершение итерации (operator!=)
            Для каждого шага цикла for проверяем условие окончания
                Как только eof = true, operator!= возвращает false => итерации завершены
        3 Получение текущего элемента operator*
            В начале каждой итерации (каждой строки CSV) разыменовывается текущий кортеж (получаем объект current_tuple на выходе)
    std::cout << row << std::endl;
        4 вывод current_tuple из 3 перегруженным <<
        5 Переход к следующей строке operator++
            После каждой итерации вызывается operator++, чтобы перейти к следующей строке CSV
    --------------------------------------------------------------------------------------
    1 Конструктор CSVParser
        В случае, если достигнут конец файла во время пропуска строк, устанавливается флаг eof, чтобы прекратить дальнейшее чтение.
    1-2 Перегрузка операторов для итерации
        begin и end - возвращают ссылки на сам объект CSVParser
        operator!= - используется для завершения итерации при достижении конца файла (eof)
        operator* - оператор разыменования, возвращает текущую строку как кортеж std::tuple<Args...>
        operator++ - считывает следующую строку, разбирает ее и сохраняет в текущем кортеже current_tuple.
    3-4
    parse_line
    |
    *-split_line
    |
    *-fill_tuple
        split_tuple - Обработка строк, их разделение и запись каждого элемента в std::vector<std::string>
        fill_tuple - заполняет кортеж current_tuple значениями std::vector<std::string>
            Используется шаблонный параметр-пакет и std::index_sequence, 
            чтобы применить преобразование каждого значения вектора к нужному типу с помощью std::istringstream.